import {
  Timeout,
  fieldValidityMapping,
  getWindow,
  isIOS,
  isWebKit,
  makeEventPreventable,
  mergeProps,
  stopEvent,
  useBaseUiId,
  useControlled,
  useEventCallback,
  useField,
  useFieldControlValidation,
  useFieldRootContext,
  useFormContext,
  useIsoLayoutEffect,
  useLatestRef,
  useOnMount,
  useRefWithInit,
  useRenderElement,
  useTimeout
} from "./chunk-LCMF2OQA.js";
import {
  require_jsx_runtime
} from "./chunk-2ZET3HRN.js";
import {
  require_react_dom
} from "./chunk-S3Z6QACX.js";
import {
  __export,
  __toESM,
  require_react
} from "./chunk-IYDKXRZQ.js";

// node_modules/@base-ui-components/react/esm/number-field/index.parts.js
var index_parts_exports = {};
__export(index_parts_exports, {
  Decrement: () => NumberFieldDecrement,
  Group: () => NumberFieldGroup,
  Increment: () => NumberFieldIncrement,
  Input: () => NumberFieldInput,
  Root: () => NumberFieldRoot,
  ScrubArea: () => NumberFieldScrubArea,
  ScrubAreaCursor: () => NumberFieldScrubAreaCursor
});

// node_modules/@base-ui-components/react/esm/number-field/root/NumberFieldRoot.js
var React3 = __toESM(require_react(), 1);

// node_modules/@base-ui-components/utils/esm/useInterval.js
var EMPTY = 0;
var Interval = class _Interval extends Timeout {
  static create() {
    return new _Interval();
  }
  /**
   * Executes `fn` at `delay` interval, clearing any previously scheduled call.
   */
  start(delay, fn) {
    this.clear();
    this.currentId = setInterval(() => {
      fn();
    }, delay);
  }
  clear = () => {
    if (this.currentId !== EMPTY) {
      clearInterval(this.currentId);
      this.currentId = EMPTY;
    }
  };
};
function useInterval() {
  const timeout = useRefWithInit(Interval.create).current;
  useOnMount(timeout.disposeEffect);
  return timeout;
}

// node_modules/@base-ui-components/utils/esm/useForcedRerendering.js
var React = __toESM(require_react());
function useForcedRerendering() {
  const [, setState] = React.useState({});
  return React.useCallback(() => {
    setState({});
  }, []);
}

// node_modules/@base-ui-components/utils/esm/owner.js
function ownerDocument(node) {
  return node?.ownerDocument || document;
}

// node_modules/@base-ui-components/react/esm/number-field/root/NumberFieldRootContext.js
var React2 = __toESM(require_react(), 1);
var NumberFieldRootContext = React2.createContext(void 0);
if (true) NumberFieldRootContext.displayName = "NumberFieldRootContext";
function useNumberFieldRootContext() {
  const context = React2.useContext(NumberFieldRootContext);
  if (context === void 0) {
    throw new Error("Base UI: NumberFieldRootContext is missing. NumberField parts must be placed within <NumberField.Root>.");
  }
  return context;
}

// node_modules/@base-ui-components/react/esm/number-field/utils/styleHooks.js
var styleHookMapping = {
  inputValue: () => null,
  value: () => null
};

// node_modules/@base-ui-components/react/esm/utils/formatNumber.js
var cache = /* @__PURE__ */ new Map();
function getFormatter(locale, options) {
  const optionsString = JSON.stringify({
    locale,
    options
  });
  const cachedFormatter = cache.get(optionsString);
  if (cachedFormatter) {
    return cachedFormatter;
  }
  const formatter = new Intl.NumberFormat(locale, options);
  cache.set(optionsString, formatter);
  return formatter;
}
function formatNumber(value, locale, options) {
  if (value == null) {
    return "";
  }
  return getFormatter(locale, options).format(value);
}
function formatNumberMaxPrecision(value, locale, options) {
  return formatNumber(value, locale, {
    ...options,
    maximumFractionDigits: 20
  });
}

// node_modules/@base-ui-components/react/esm/number-field/utils/parse.js
var HAN_NUMERALS = ["零", "一", "二", "三", "四", "五", "六", "七", "八", "九"];
var ARABIC_NUMERALS = ["٠", "١", "٢", "٣", "٤", "٥", "٦", "٧", "٨", "٩"];
var PERCENTAGES = ["%", "٪"];
var ARABIC_RE = new RegExp(`[${ARABIC_NUMERALS.join("")}]`, "g");
var HAN_RE = new RegExp(`[${HAN_NUMERALS.join("")}]`, "g");
var PERCENT_RE = new RegExp(`[${PERCENTAGES.join("")}]`);
function getNumberLocaleDetails(locale, options) {
  const parts = getFormatter(locale, options).formatToParts(11111.1);
  const result = {};
  parts.forEach((part) => {
    result[part.type] = part.value;
  });
  getFormatter(locale).formatToParts(0.1).forEach((part) => {
    if (part.type === "decimal") {
      result[part.type] = part.value;
    }
  });
  return result;
}
function parseNumber(formattedNumber, locale, options) {
  let computedLocale = locale;
  if (computedLocale === void 0) {
    if (ARABIC_RE.test(formattedNumber)) {
      computedLocale = "ar";
    } else if (HAN_RE.test(formattedNumber)) {
      computedLocale = "zh";
    }
  }
  const {
    group,
    decimal,
    currency,
    unit
  } = getNumberLocaleDetails(computedLocale, options);
  let groupRegex = null;
  if (group) {
    groupRegex = new RegExp("\\p{Zs}", "u").test(group) ? new RegExp("\\p{Zs}", "gu") : new RegExp(`\\${group}`, "g");
  }
  const regexesToReplace = [{
    regex: group ? groupRegex : null,
    replacement: ""
  }, {
    regex: decimal ? new RegExp(`\\${decimal}`, "g") : null,
    replacement: "."
  }, {
    regex: currency ? new RegExp(`\\${currency}`, "g") : null,
    replacement: ""
  }, {
    regex: unit ? new RegExp(`\\${unit}`, "g") : null,
    replacement: ""
  }, {
    regex: ARABIC_RE,
    replacement: (match) => ARABIC_NUMERALS.indexOf(match).toString()
  }, {
    regex: HAN_RE,
    replacement: (match) => HAN_NUMERALS.indexOf(match).toString()
  }];
  const unformattedNumber = regexesToReplace.reduce((acc, {
    regex,
    replacement
  }) => {
    if (!regex) {
      return acc;
    }
    return acc.replace(regex, replacement);
  }, formattedNumber);
  let num = parseFloat(unformattedNumber);
  const style = options?.style;
  const isUnitPercent = style === "unit" && options?.unit === "percent";
  const isPercent = PERCENT_RE.test(formattedNumber) || style === "percent";
  if (!isUnitPercent && isPercent) {
    num /= 100;
  }
  if (Number.isNaN(num)) {
    return null;
  }
  return num;
}

// node_modules/@base-ui-components/react/esm/number-field/utils/constants.js
var CHANGE_VALUE_TICK_DELAY = 60;
var START_AUTO_CHANGE_DELAY = 400;
var TOUCH_TIMEOUT = 50;
var MAX_POINTER_MOVES_AFTER_TOUCH = 3;
var SCROLLING_POINTER_MOVE_DISTANCE = 8;
var DEFAULT_STEP = 1;

// node_modules/@base-ui-components/react/esm/utils/clamp.js
function clamp(val, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER) {
  return Math.max(min, Math.min(val, max));
}

// node_modules/@base-ui-components/react/esm/number-field/utils/validate.js
function removeFloatingPointErrors(value, format = {}) {
  return parseFloat(getFormatter("en-US", {
    maximumFractionDigits: format.maximumFractionDigits,
    minimumFractionDigits: format.minimumFractionDigits,
    useGrouping: false
  }).format(value));
}
function toValidatedNumber(value, {
  step,
  minWithDefault,
  maxWithDefault,
  minWithZeroDefault,
  format,
  snapOnStep,
  small
}) {
  if (value === null) {
    return value;
  }
  const clampedValue = clamp(value, minWithDefault, maxWithDefault);
  if (step != null && snapOnStep) {
    if (small) {
      const stepsFromMin = (clampedValue - minWithZeroDefault) / step;
      const roundedSteps = Math.round(stepsFromMin);
      const snappedValue = minWithZeroDefault + roundedSteps * step;
      return removeFloatingPointErrors(snappedValue, format);
    }
    const base = minWithDefault !== Number.MIN_SAFE_INTEGER ? minWithDefault : minWithZeroDefault;
    if (step > 0) {
      const unsnapped = clampedValue - step;
      const steps = Math.floor((unsnapped - base) / step);
      return removeFloatingPointErrors(base + steps * step + step, format);
    }
    if (step < 0) {
      const absStep = Math.abs(step);
      const unsnapped = clampedValue - step;
      const steps = Math.ceil((unsnapped - base) / absStep);
      return removeFloatingPointErrors(base + steps * absStep + step, format);
    }
  }
  return removeFloatingPointErrors(clampedValue, format);
}

// node_modules/@base-ui-components/react/esm/number-field/root/NumberFieldRoot.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var NumberFieldRoot = React3.forwardRef(function NumberFieldRoot2(componentProps, forwardedRef) {
  const {
    id: idProp,
    min,
    max,
    smallStep = 0.1,
    step = 1,
    largeStep = 10,
    required = false,
    disabled: disabledProp = false,
    readOnly = false,
    name: nameProp,
    defaultValue,
    value: valueProp,
    onValueChange: onValueChangeProp,
    allowWheelScrub = false,
    snapOnStep = false,
    format,
    locale,
    render,
    className,
    inputRef: inputRefProp,
    ...elementProps
  } = componentProps;
  const {
    setControlId,
    setDirty,
    validityData,
    setValidityData,
    disabled: fieldDisabled,
    setFilled,
    invalid,
    name: fieldName,
    state: fieldState
  } = useFieldRootContext();
  const disabled = fieldDisabled || disabledProp;
  const name = fieldName ?? nameProp;
  const [isScrubbing, setIsScrubbing] = React3.useState(false);
  const minWithDefault = min ?? Number.MIN_SAFE_INTEGER;
  const maxWithDefault = max ?? Number.MAX_SAFE_INTEGER;
  const minWithZeroDefault = min ?? 0;
  const formatStyle = format?.style;
  const inputRef = React3.useRef(null);
  const id = useBaseUiId(idProp);
  useIsoLayoutEffect(() => {
    setControlId(id);
    return () => {
      setControlId(void 0);
    };
  }, [id, setControlId]);
  const [valueUnwrapped, setValueUnwrapped] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "NumberField",
    state: "value"
  });
  const value = valueUnwrapped ?? null;
  const valueRef = useLatestRef(value);
  useIsoLayoutEffect(() => {
    setFilled(value !== null);
  }, [setFilled, value]);
  const forceRender = useForcedRerendering();
  const formatOptionsRef = useLatestRef(format);
  const onValueChange = useEventCallback(onValueChangeProp);
  const startTickTimeout = useTimeout();
  const tickInterval = useInterval();
  const intentionalTouchCheckTimeout = useTimeout();
  const isPressedRef = React3.useRef(false);
  const movesAfterTouchRef = React3.useRef(0);
  const allowInputSyncRef = React3.useRef(true);
  const unsubscribeFromGlobalContextMenuRef = React3.useRef(() => {
  });
  useIsoLayoutEffect(() => {
    if (validityData.initialValue === null && value !== validityData.initialValue) {
      setValidityData((prev) => ({
        ...prev,
        initialValue: value
      }));
    }
  }, [setValidityData, validityData.initialValue, value]);
  const [inputValue, setInputValue] = React3.useState(() => {
    if (valueProp !== void 0) {
      return getControlledInputValue(value, locale, format);
    }
    return formatNumber(value, locale, format);
  });
  const [inputMode, setInputMode] = React3.useState("numeric");
  const getAllowedNonNumericKeys = useEventCallback(() => {
    const {
      decimal,
      group,
      currency
    } = getNumberLocaleDetails(locale, format);
    const keys = /* @__PURE__ */ new Set([".", ",", decimal, group]);
    if (formatStyle === "percent") {
      PERCENTAGES.forEach((key) => keys.add(key));
    }
    if (formatStyle === "currency" && currency) {
      keys.add(currency);
    }
    if (minWithDefault < 0) {
      keys.add("-");
    }
    return keys;
  });
  const getStepAmount = useEventCallback((event) => {
    if (event?.altKey) {
      return smallStep;
    }
    if (event?.shiftKey) {
      return largeStep;
    }
    return step;
  });
  const setValue = useEventCallback((unvalidatedValue, event, dir) => {
    const eventWithOptionalKeyState = event;
    const validatedValue = toValidatedNumber(unvalidatedValue, {
      step: dir ? getStepAmount(eventWithOptionalKeyState) * dir : void 0,
      format: formatOptionsRef.current,
      minWithDefault,
      maxWithDefault,
      minWithZeroDefault,
      snapOnStep,
      small: eventWithOptionalKeyState?.altKey ?? false
    });
    onValueChange?.(validatedValue, event && "nativeEvent" in event ? event.nativeEvent : event);
    setValueUnwrapped(validatedValue);
    setDirty(validatedValue !== validityData.initialValue);
    if (allowInputSyncRef.current) {
      setInputValue(formatNumber(validatedValue, locale, format));
    }
    forceRender();
  });
  const incrementValue = useEventCallback((amount, dir, currentValue, event) => {
    const prevValue = currentValue == null ? valueRef.current : currentValue;
    const nextValue = typeof prevValue === "number" ? prevValue + amount * dir : Math.max(0, min ?? 0);
    setValue(nextValue, event, dir);
  });
  const stopAutoChange = useEventCallback(() => {
    intentionalTouchCheckTimeout.clear();
    startTickTimeout.clear();
    tickInterval.clear();
    unsubscribeFromGlobalContextMenuRef.current();
    movesAfterTouchRef.current = 0;
  });
  const startAutoChange = useEventCallback((isIncrement, triggerEvent) => {
    stopAutoChange();
    if (!inputRef.current) {
      return;
    }
    const win = getWindow(inputRef.current);
    function handleContextMenu(event) {
      event.preventDefault();
    }
    win.addEventListener("contextmenu", handleContextMenu);
    unsubscribeFromGlobalContextMenuRef.current = () => {
      win.removeEventListener("contextmenu", handleContextMenu);
    };
    win.addEventListener("pointerup", () => {
      isPressedRef.current = false;
      stopAutoChange();
    }, {
      once: true
    });
    function tick() {
      const amount = getStepAmount(triggerEvent) ?? DEFAULT_STEP;
      incrementValue(amount, isIncrement ? 1 : -1, void 0, triggerEvent);
    }
    tick();
    startTickTimeout.start(START_AUTO_CHANGE_DELAY, () => {
      tickInterval.start(CHANGE_VALUE_TICK_DELAY, tick);
    });
  });
  useIsoLayoutEffect(function syncFormattedInputValueOnValueChange() {
    if (!allowInputSyncRef.current) {
      return;
    }
    const nextInputValue = valueProp !== void 0 ? getControlledInputValue(value, locale, format) : formatNumber(value, locale, format);
    if (nextInputValue !== inputValue) {
      setInputValue(nextInputValue);
    }
  });
  useIsoLayoutEffect(function setDynamicInputModeForIOS() {
    if (!isIOS) {
      return;
    }
    let computedInputMode = "text";
    if (minWithDefault >= 0) {
      computedInputMode = "decimal";
    }
    setInputMode(computedInputMode);
  }, [minWithDefault, formatStyle]);
  React3.useEffect(() => {
    return () => stopAutoChange();
  }, [stopAutoChange]);
  React3.useEffect(function registerElementWheelListener() {
    const element2 = inputRef.current;
    if (disabled || readOnly || !allowWheelScrub || !element2) {
      return void 0;
    }
    function handleWheel(event) {
      if (
        // Allow pinch-zooming.
        event.ctrlKey || ownerDocument(inputRef.current).activeElement !== inputRef.current
      ) {
        return;
      }
      event.preventDefault();
      const amount = getStepAmount(event) ?? DEFAULT_STEP;
      incrementValue(amount, event.deltaY > 0 ? -1 : 1, void 0, event);
    }
    element2.addEventListener("wheel", handleWheel);
    return () => {
      element2.removeEventListener("wheel", handleWheel);
    };
  }, [allowWheelScrub, incrementValue, disabled, readOnly, largeStep, step, getStepAmount]);
  const state = React3.useMemo(() => ({
    ...fieldState,
    disabled,
    readOnly,
    required,
    value,
    inputValue,
    scrubbing: isScrubbing
  }), [fieldState, disabled, readOnly, required, value, inputValue, isScrubbing]);
  const contextValue = React3.useMemo(() => ({
    inputRef,
    inputValue,
    value,
    startAutoChange,
    stopAutoChange,
    minWithDefault,
    maxWithDefault,
    disabled,
    readOnly,
    id,
    setValue,
    incrementValue,
    getStepAmount,
    allowInputSyncRef,
    formatOptionsRef,
    valueRef,
    isPressedRef,
    intentionalTouchCheckTimeout,
    movesAfterTouchRef,
    name,
    required,
    invalid,
    inputMode,
    getAllowedNonNumericKeys,
    min,
    max,
    setInputValue,
    locale,
    isScrubbing,
    setIsScrubbing,
    state
  }), [inputRef, inputValue, value, startAutoChange, stopAutoChange, minWithDefault, maxWithDefault, disabled, readOnly, id, setValue, incrementValue, getStepAmount, allowInputSyncRef, formatOptionsRef, valueRef, isPressedRef, intentionalTouchCheckTimeout, movesAfterTouchRef, name, required, invalid, inputMode, getAllowedNonNumericKeys, min, max, setInputValue, locale, isScrubbing, state]);
  const element = useRenderElement("div", componentProps, {
    ref: forwardedRef,
    state,
    props: elementProps,
    customStyleHookMapping: styleHookMapping
  });
  return (0, import_jsx_runtime.jsxs)(NumberFieldRootContext.Provider, {
    value: contextValue,
    children: [element, name && (0, import_jsx_runtime.jsx)("input", {
      type: "hidden",
      name,
      ref: inputRefProp,
      value: value ?? "",
      disabled,
      required
    })]
  });
});
if (true) NumberFieldRoot.displayName = "NumberFieldRoot";
function getControlledInputValue(value, locale, format) {
  const explicitPrecision = format?.maximumFractionDigits != null || format?.minimumFractionDigits != null;
  return explicitPrecision ? formatNumber(value, locale, format) : formatNumberMaxPrecision(value, locale, format);
}

// node_modules/@base-ui-components/react/esm/number-field/group/NumberFieldGroup.js
var React4 = __toESM(require_react(), 1);
var NumberFieldGroup = React4.forwardRef(function NumberFieldGroup2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    state
  } = useNumberFieldRootContext();
  const element = useRenderElement("div", componentProps, {
    ref: forwardedRef,
    state,
    props: [{
      role: "group"
    }, elementProps],
    customStyleHookMapping: styleHookMapping
  });
  return element;
});
if (true) NumberFieldGroup.displayName = "NumberFieldGroup";

// node_modules/@base-ui-components/react/esm/number-field/increment/NumberFieldIncrement.js
var React9 = __toESM(require_react(), 1);

// node_modules/@base-ui-components/react/esm/use-button/useButton.js
var React7 = __toESM(require_react(), 1);

// node_modules/@base-ui-components/utils/esm/error.js
var set;
if (true) {
  set = /* @__PURE__ */ new Set();
}
function error(...messages) {
  if (true) {
    const messageKey = messages.join(" ");
    if (!set.has(messageKey)) {
      set.add(messageKey);
      console.error(`Base UI: ${messageKey}`);
    }
  }
}

// node_modules/@base-ui-components/react/esm/composite/root/CompositeRootContext.js
var React5 = __toESM(require_react(), 1);
var CompositeRootContext = React5.createContext(void 0);
if (true) CompositeRootContext.displayName = "CompositeRootContext";
function useCompositeRootContext(optional = false) {
  const context = React5.useContext(CompositeRootContext);
  if (context === void 0 && !optional) {
    throw new Error("Base UI: CompositeRootContext is missing. Composite parts must be placed within <Composite.Root>.");
  }
  return context;
}

// node_modules/@base-ui-components/react/esm/utils/useFocusableWhenDisabled.js
var React6 = __toESM(require_react(), 1);
function useFocusableWhenDisabled(parameters) {
  const {
    focusableWhenDisabled,
    disabled,
    composite = false,
    tabIndex: tabIndexProp = 0,
    isNativeButton
  } = parameters;
  const isFocusableComposite = composite && focusableWhenDisabled !== false;
  const isNonFocusableComposite = composite && focusableWhenDisabled === false;
  const props = React6.useMemo(() => {
    const additionalProps = {
      // allow Tabbing away from focusableWhenDisabled elements
      onKeyDown(event) {
        if (disabled && focusableWhenDisabled && event.key !== "Tab") {
          event.preventDefault();
        }
      }
    };
    if (!composite) {
      additionalProps.tabIndex = tabIndexProp;
      if (!isNativeButton && disabled) {
        additionalProps.tabIndex = focusableWhenDisabled ? tabIndexProp : -1;
      }
    }
    if (isNativeButton && (focusableWhenDisabled || isFocusableComposite) || !isNativeButton && disabled) {
      additionalProps["aria-disabled"] = disabled;
    }
    if (isNativeButton && (!focusableWhenDisabled || isNonFocusableComposite)) {
      additionalProps.disabled = disabled;
    }
    return additionalProps;
  }, [composite, disabled, focusableWhenDisabled, isFocusableComposite, isNonFocusableComposite, isNativeButton, tabIndexProp]);
  return {
    props
  };
}

// node_modules/@base-ui-components/react/esm/use-button/useButton.js
function useButton(parameters = {}) {
  const {
    disabled = false,
    focusableWhenDisabled,
    tabIndex = 0,
    native: isNativeButton = true
  } = parameters;
  const buttonRef = React7.useRef(null);
  const isCompositeItem = useCompositeRootContext(true) !== void 0;
  const isValidLink = useEventCallback(() => {
    const element = buttonRef.current;
    return Boolean(element?.tagName === "A" && element?.href);
  });
  const {
    props: focusableWhenDisabledProps
  } = useFocusableWhenDisabled({
    focusableWhenDisabled,
    disabled,
    composite: isCompositeItem,
    tabIndex,
    isNativeButton
  });
  if (true) {
    React7.useEffect(() => {
      if (!buttonRef.current) {
        return;
      }
      const isButtonTag = buttonRef.current.tagName === "BUTTON";
      if (isNativeButton) {
        if (!isButtonTag) {
          error("A component that acts as a button was not rendered as a native <button>, which does not match the default. Ensure that the element passed to the `render` prop of the component is a real <button>, or set the `nativeButton` prop on the component to `false`.");
        }
      } else if (isButtonTag) {
        error("A component that acts as a button was rendered as a native <button>, which does not match the default. Ensure that the element passed to the `render` prop of the component is not a real <button>, or set the `nativeButton` prop on the component to `true`.");
      }
    }, [isNativeButton]);
  }
  useIsoLayoutEffect(() => {
    const element = buttonRef.current;
    if (!(element instanceof HTMLButtonElement)) {
      return;
    }
    if (isCompositeItem && disabled && focusableWhenDisabledProps.disabled === void 0 && element.disabled) {
      element.disabled = false;
    }
  }, [disabled, focusableWhenDisabledProps.disabled, isCompositeItem]);
  const getButtonProps = React7.useCallback((externalProps = {}) => {
    const {
      onClick: externalOnClick,
      onMouseDown: externalOnMouseDown,
      onKeyUp: externalOnKeyUp,
      onKeyDown: externalOnKeyDown,
      onPointerDown: externalOnPointerDown,
      ...otherExternalProps
    } = externalProps;
    const type = isNativeButton ? "button" : void 0;
    return mergeProps({
      type,
      onClick(event) {
        if (disabled) {
          event.preventDefault();
          return;
        }
        externalOnClick?.(event);
      },
      onMouseDown(event) {
        if (!disabled) {
          externalOnMouseDown?.(event);
        }
      },
      onKeyDown(event) {
        if (!disabled) {
          makeEventPreventable(event);
          externalOnKeyDown?.(event);
        }
        if (event.baseUIHandlerPrevented) {
          return;
        }
        const shouldClick = event.target === event.currentTarget && !isNativeButton && !isValidLink() && !disabled;
        const isEnterKey = event.key === "Enter";
        const isSpaceKey = event.key === " ";
        if (shouldClick) {
          if (isSpaceKey || isEnterKey) {
            event.preventDefault();
          }
          if (isEnterKey) {
            externalOnClick?.(event);
          }
        }
      },
      onKeyUp(event) {
        if (!disabled) {
          makeEventPreventable(event);
          externalOnKeyUp?.(event);
        }
        if (event.baseUIHandlerPrevented) {
          return;
        }
        if (event.target === event.currentTarget && !isNativeButton && !disabled && event.key === " ") {
          externalOnClick?.(event);
        }
      },
      onPointerDown(event) {
        if (disabled) {
          event.preventDefault();
          return;
        }
        externalOnPointerDown?.(event);
      }
    }, !isNativeButton ? {
      role: "button"
    } : void 0, focusableWhenDisabledProps, otherExternalProps);
  }, [disabled, focusableWhenDisabledProps, isNativeButton, isValidLink]);
  return {
    getButtonProps,
    buttonRef
  };
}

// node_modules/@base-ui-components/react/esm/number-field/root/useNumberFieldButton.js
var React8 = __toESM(require_react(), 1);
function useNumberFieldButton(params) {
  const {
    allowInputSyncRef,
    disabled,
    formatOptionsRef,
    getStepAmount,
    id,
    incrementValue,
    inputRef,
    inputValue,
    intentionalTouchCheckTimeout,
    isIncrement,
    isPressedRef,
    locale,
    maxWithDefault,
    minWithDefault,
    movesAfterTouchRef,
    readOnly,
    setValue,
    startAutoChange,
    stopAutoChange,
    value,
    valueRef
  } = params;
  const incrementDownCoordsRef = React8.useRef({
    x: 0,
    y: 0
  });
  const isTouchingButtonRef = React8.useRef(false);
  const ignoreClickRef = React8.useRef(false);
  const pointerTypeRef = React8.useRef("");
  const isMin = value != null && value <= minWithDefault;
  const isMax = value != null && value >= maxWithDefault;
  const commitValue = useEventCallback((nativeEvent) => {
    allowInputSyncRef.current = true;
    const parsedValue = parseNumber(inputValue, locale, formatOptionsRef.current);
    if (parsedValue !== null) {
      valueRef.current = parsedValue;
      setValue(parsedValue, nativeEvent);
    }
  });
  const props = React8.useMemo(() => ({
    disabled: disabled || (isIncrement ? isMax : isMin),
    "aria-readonly": readOnly || void 0,
    "aria-label": isIncrement ? "Increase" : "Decrease",
    "aria-controls": id,
    // Keyboard users shouldn't have access to the buttons, since they can use the input element
    // to change the value. On the other hand, `aria-hidden` is not applied because touch screen
    // readers should be able to use the buttons.
    tabIndex: -1,
    style: {
      WebkitUserSelect: "none",
      userSelect: "none"
    },
    onTouchStart() {
      isTouchingButtonRef.current = true;
    },
    onTouchEnd() {
      isTouchingButtonRef.current = false;
    },
    onClick(event) {
      const isDisabled = disabled || readOnly || (isIncrement ? isMax : isMin);
      if (event.defaultPrevented || isDisabled || // If it's not a keyboard/virtual click, ignore.
      (pointerTypeRef.current === "touch" ? ignoreClickRef.current : event.detail !== 0)) {
        return;
      }
      commitValue(event.nativeEvent);
      const amount = getStepAmount(event) ?? DEFAULT_STEP;
      incrementValue(amount, isIncrement ? 1 : -1, void 0, event.nativeEvent);
    },
    onPointerDown(event) {
      const isMainButton = !event.button || event.button === 0;
      const isDisabled = disabled || (isIncrement ? isMax : isMin);
      if (event.defaultPrevented || readOnly || !isMainButton || isDisabled) {
        return;
      }
      pointerTypeRef.current = event.pointerType;
      ignoreClickRef.current = false;
      isPressedRef.current = true;
      incrementDownCoordsRef.current = {
        x: event.clientX,
        y: event.clientY
      };
      commitValue(event.nativeEvent);
      if (event.pointerType !== "touch") {
        event.preventDefault();
        inputRef.current?.focus();
        startAutoChange(isIncrement, event);
      } else {
        intentionalTouchCheckTimeout.start(TOUCH_TIMEOUT, () => {
          const moves = movesAfterTouchRef.current;
          movesAfterTouchRef.current = 0;
          if (moves != null && moves < MAX_POINTER_MOVES_AFTER_TOUCH) {
            ignoreClickRef.current = true;
            startAutoChange(isIncrement, event);
          } else {
            stopAutoChange();
          }
        });
      }
    },
    onPointerMove(event) {
      const isDisabled = disabled || readOnly || (isIncrement ? isMax : isMin);
      if (isDisabled || event.pointerType !== "touch" || !isPressedRef.current) {
        return;
      }
      if (movesAfterTouchRef.current != null) {
        movesAfterTouchRef.current += 1;
      }
      const {
        x,
        y
      } = incrementDownCoordsRef.current;
      const dx = x - event.clientX;
      const dy = y - event.clientY;
      if (dx ** 2 + dy ** 2 > SCROLLING_POINTER_MOVE_DISTANCE ** 2) {
        stopAutoChange();
      }
    },
    onMouseEnter(event) {
      const isDisabled = disabled || readOnly || (isIncrement ? isMax : isMin);
      if (event.defaultPrevented || isDisabled || !isPressedRef.current || isTouchingButtonRef.current) {
        return;
      }
      startAutoChange(isIncrement, event);
    },
    onMouseLeave() {
      if (isTouchingButtonRef.current) {
        return;
      }
      stopAutoChange();
    },
    onMouseUp() {
      if (isTouchingButtonRef.current) {
        return;
      }
      stopAutoChange();
    }
  }), [commitValue, disabled, getStepAmount, id, incrementValue, inputRef, isIncrement, intentionalTouchCheckTimeout, isMax, isMin, isPressedRef, movesAfterTouchRef, readOnly, startAutoChange, stopAutoChange]);
  return React8.useMemo(() => ({
    props
  }), [props]);
}

// node_modules/@base-ui-components/react/esm/number-field/increment/NumberFieldIncrement.js
var NumberFieldIncrement = React9.forwardRef(function NumberFieldIncrement2(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled: disabledProp = false,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const {
    allowInputSyncRef,
    disabled: contextDisabled,
    formatOptionsRef,
    getStepAmount,
    id,
    incrementValue,
    inputRef,
    inputValue,
    intentionalTouchCheckTimeout,
    isPressedRef,
    locale,
    maxWithDefault,
    minWithDefault,
    movesAfterTouchRef,
    readOnly,
    setValue,
    startAutoChange,
    state,
    stopAutoChange,
    value,
    valueRef
  } = useNumberFieldRootContext();
  const disabled = disabledProp || contextDisabled;
  const {
    props
  } = useNumberFieldButton({
    isIncrement: true,
    inputRef,
    startAutoChange,
    stopAutoChange,
    minWithDefault,
    maxWithDefault,
    value,
    inputValue,
    disabled,
    readOnly,
    id,
    setValue,
    getStepAmount,
    incrementValue,
    allowInputSyncRef,
    formatOptionsRef,
    valueRef,
    isPressedRef,
    intentionalTouchCheckTimeout,
    movesAfterTouchRef,
    locale
  });
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton
  });
  const buttonState = React9.useMemo(() => ({
    ...state,
    disabled
  }), [state, disabled]);
  const element = useRenderElement("button", componentProps, {
    ref: [forwardedRef, buttonRef],
    state: buttonState,
    props: [props, elementProps, getButtonProps],
    customStyleHookMapping: styleHookMapping
  });
  return element;
});
if (true) NumberFieldIncrement.displayName = "NumberFieldIncrement";

// node_modules/@base-ui-components/react/esm/number-field/decrement/NumberFieldDecrement.js
var React10 = __toESM(require_react(), 1);
var NumberFieldDecrement = React10.forwardRef(function NumberFieldDecrement2(componentProps, forwardedRef) {
  const {
    render,
    className,
    disabled: disabledProp = false,
    nativeButton = true,
    ...elementProps
  } = componentProps;
  const {
    allowInputSyncRef,
    disabled: contextDisabled,
    formatOptionsRef,
    getStepAmount,
    id,
    incrementValue,
    inputRef,
    inputValue,
    intentionalTouchCheckTimeout,
    isPressedRef,
    maxWithDefault,
    minWithDefault,
    movesAfterTouchRef,
    readOnly,
    setValue,
    startAutoChange,
    state,
    stopAutoChange,
    value,
    valueRef,
    locale
  } = useNumberFieldRootContext();
  const disabled = disabledProp || contextDisabled;
  const {
    props
  } = useNumberFieldButton({
    isIncrement: false,
    inputRef,
    startAutoChange,
    stopAutoChange,
    minWithDefault,
    maxWithDefault,
    value,
    inputValue,
    disabled,
    readOnly,
    id,
    setValue,
    getStepAmount,
    incrementValue,
    allowInputSyncRef,
    formatOptionsRef,
    valueRef,
    isPressedRef,
    intentionalTouchCheckTimeout,
    movesAfterTouchRef,
    locale
  });
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    native: nativeButton
  });
  const buttonState = React10.useMemo(() => ({
    ...state,
    disabled
  }), [state, disabled]);
  const element = useRenderElement("button", componentProps, {
    ref: [forwardedRef, buttonRef],
    state: buttonState,
    props: [props, elementProps, getButtonProps],
    customStyleHookMapping: styleHookMapping
  });
  return element;
});
if (true) NumberFieldDecrement.displayName = "NumberFieldDecrement";

// node_modules/@base-ui-components/react/esm/number-field/input/NumberFieldInput.js
var React11 = __toESM(require_react(), 1);
var customStyleHookMapping = {
  ...fieldValidityMapping,
  ...styleHookMapping
};
var NAVIGATE_KEYS = /* @__PURE__ */ new Set(["Backspace", "Delete", "ArrowLeft", "ArrowRight", "Tab", "Enter", "Escape"]);
var NumberFieldInput = React11.forwardRef(function NumberFieldInput2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    allowInputSyncRef,
    disabled,
    formatOptionsRef,
    getAllowedNonNumericKeys,
    getStepAmount,
    id,
    incrementValue,
    inputMode,
    inputValue,
    max,
    min,
    name,
    readOnly,
    required,
    setValue,
    state,
    setInputValue,
    locale,
    inputRef,
    value
  } = useNumberFieldRootContext();
  const {
    clearErrors
  } = useFormContext();
  const {
    labelId,
    validationMode,
    setTouched,
    setFocused,
    invalid
  } = useFieldRootContext();
  const {
    getInputValidationProps,
    getValidationProps,
    commitValidation,
    inputRef: inputValidationRef
  } = useFieldControlValidation();
  const hasTouchedInputRef = React11.useRef(false);
  const blockRevalidationRef = React11.useRef(false);
  useField({
    id,
    commitValidation,
    value,
    controlRef: inputRef,
    name,
    getValue: () => value ?? null
  });
  const prevValueRef = React11.useRef(value);
  const prevInputValueRef = React11.useRef(inputValue);
  useIsoLayoutEffect(() => {
    if (prevValueRef.current === value && prevInputValueRef.current === inputValue) {
      return;
    }
    clearErrors(name);
    if (validationMode === "onChange") {
      commitValidation(value);
    }
  }, [value, inputValue, name, clearErrors, validationMode, commitValidation]);
  useIsoLayoutEffect(() => {
    if (prevValueRef.current === value || validationMode === "onChange") {
      return;
    }
    if (blockRevalidationRef.current) {
      blockRevalidationRef.current = false;
      return;
    }
    commitValidation(value, true);
  }, [commitValidation, validationMode, value]);
  useIsoLayoutEffect(() => {
    prevValueRef.current = value;
    prevInputValueRef.current = inputValue;
  }, [value, inputValue]);
  const inputProps = {
    id,
    required,
    disabled,
    readOnly,
    inputMode,
    value: inputValue,
    type: "text",
    autoComplete: "off",
    autoCorrect: "off",
    spellCheck: "false",
    "aria-roledescription": "Number field",
    "aria-invalid": invalid || void 0,
    "aria-labelledby": labelId,
    // If the server's locale does not match the client's locale, the formatting may not match,
    // causing a hydration mismatch.
    suppressHydrationWarning: true,
    onFocus(event) {
      if (event.defaultPrevented || readOnly || disabled || hasTouchedInputRef.current) {
        return;
      }
      hasTouchedInputRef.current = true;
      setFocused(true);
      const target = event.currentTarget;
      const length = target.value.length;
      target.setSelectionRange(length, length);
    },
    onBlur(event) {
      if (event.defaultPrevented || readOnly || disabled) {
        return;
      }
      setTouched(true);
      setFocused(false);
      allowInputSyncRef.current = true;
      if (inputValue.trim() === "") {
        setValue(null);
        if (validationMode === "onBlur") {
          commitValidation(null);
        }
        return;
      }
      const formatOptions = formatOptionsRef.current;
      const parsedValue = parseNumber(inputValue, locale, formatOptions);
      const canonicalText = formatNumber(parsedValue, locale, formatOptions);
      const maxPrecisionText = formatNumberMaxPrecision(parsedValue, locale, formatOptions);
      const canonical = parseNumber(canonicalText, locale, formatOptions);
      const maxPrecision = parseNumber(maxPrecisionText, locale, formatOptions);
      if (parsedValue === null) {
        return;
      }
      blockRevalidationRef.current = true;
      if (validationMode === "onBlur") {
        commitValidation(canonical);
      }
      const hasExplicitPrecision = formatOptions?.maximumFractionDigits != null || formatOptions?.minimumFractionDigits != null;
      if (hasExplicitPrecision) {
        if (value !== canonical) {
          setValue(canonical, event.nativeEvent);
        }
        if (inputValue !== canonicalText) {
          setInputValue(canonicalText);
        }
      } else if (value !== maxPrecision) {
        setValue(canonical, event.nativeEvent);
      } else {
        const shouldPreserveFullPrecision = parsedValue === value && inputValue === maxPrecisionText;
        if (!shouldPreserveFullPrecision && inputValue !== canonicalText) {
          setInputValue(canonicalText);
        }
      }
    },
    onChange(event) {
      if (event.nativeEvent.defaultPrevented) {
        return;
      }
      allowInputSyncRef.current = false;
      const targetValue = event.target.value;
      if (targetValue.trim() === "") {
        setInputValue(targetValue);
        setValue(null, event.nativeEvent);
        return;
      }
      if (event.isTrusted) {
        setInputValue(targetValue);
        return;
      }
      const parsedValue = parseNumber(targetValue, locale, formatOptionsRef.current);
      if (parsedValue !== null) {
        setInputValue(targetValue);
        setValue(parsedValue, event.nativeEvent);
      }
    },
    onKeyDown(event) {
      if (event.defaultPrevented || readOnly || disabled) {
        return;
      }
      const nativeEvent = event.nativeEvent;
      allowInputSyncRef.current = true;
      const allowedNonNumericKeys = getAllowedNonNumericKeys();
      let isAllowedNonNumericKey = allowedNonNumericKeys.has(event.key);
      const {
        decimal,
        currency,
        percentSign
      } = getNumberLocaleDetails([], formatOptionsRef.current);
      const selectionStart = event.currentTarget.selectionStart;
      const selectionEnd = event.currentTarget.selectionEnd;
      const isAllSelected = selectionStart === 0 && selectionEnd === inputValue.length;
      if (event.key === "-" && allowedNonNumericKeys.has("-")) {
        const isMinusHighlighted = selectionStart === 0 && selectionEnd === 1 && inputValue[0] === "-";
        isAllowedNonNumericKey = !inputValue.includes("-") || isAllSelected || isMinusHighlighted;
      }
      [decimal, currency, percentSign].forEach((symbol) => {
        if (event.key === symbol) {
          const symbolIndex = inputValue.indexOf(symbol);
          const isSymbolHighlighted = selectionStart === symbolIndex && selectionEnd === symbolIndex + 1;
          isAllowedNonNumericKey = !inputValue.includes(symbol) || isAllSelected || isSymbolHighlighted;
        }
      });
      const isLatinNumeral = /^[0-9]$/.test(event.key);
      const isArabicNumeral = ARABIC_RE.test(event.key);
      const isHanNumeral = HAN_RE.test(event.key);
      const isNavigateKey = NAVIGATE_KEYS.has(event.key);
      if (
        // Allow composition events (e.g., pinyin)
        // event.nativeEvent.isComposing does not work in Safari:
        // https://bugs.webkit.org/show_bug.cgi?id=165004
        event.which === 229 || event.altKey || event.ctrlKey || event.metaKey || isAllowedNonNumericKey || isLatinNumeral || isArabicNumeral || isHanNumeral || isNavigateKey
      ) {
        return;
      }
      const parsedValue = parseNumber(inputValue, locale, formatOptionsRef.current);
      const amount = getStepAmount(event) ?? DEFAULT_STEP;
      stopEvent(event);
      if (event.key === "ArrowUp") {
        incrementValue(amount, 1, parsedValue, nativeEvent);
      } else if (event.key === "ArrowDown") {
        incrementValue(amount, -1, parsedValue, nativeEvent);
      } else if (event.key === "Home" && min != null) {
        setValue(min, nativeEvent);
      } else if (event.key === "End" && max != null) {
        setValue(max, nativeEvent);
      }
    },
    onPaste(event) {
      if (event.defaultPrevented || readOnly || disabled) {
        return;
      }
      event.preventDefault();
      const clipboardData = event.clipboardData || window.Clipboard;
      const pastedData = clipboardData.getData("text/plain");
      const parsedValue = parseNumber(pastedData, locale, formatOptionsRef.current);
      if (parsedValue !== null) {
        allowInputSyncRef.current = false;
        setValue(parsedValue, event.nativeEvent);
        setInputValue(pastedData);
      }
    }
  };
  const element = useRenderElement("input", componentProps, {
    ref: [forwardedRef, inputRef, inputValidationRef],
    state,
    props: [inputProps, getInputValidationProps(), getValidationProps(), elementProps],
    customStyleHookMapping
  });
  return element;
});
if (true) NumberFieldInput.displayName = "NumberFieldInput";

// node_modules/@base-ui-components/react/esm/number-field/scrub-area/NumberFieldScrubArea.js
var React13 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);

// node_modules/@base-ui-components/react/esm/number-field/scrub-area/NumberFieldScrubAreaContext.js
var React12 = __toESM(require_react(), 1);
var NumberFieldScrubAreaContext = React12.createContext(void 0);
if (true) NumberFieldScrubAreaContext.displayName = "NumberFieldScrubAreaContext";
function useNumberFieldScrubAreaContext() {
  const context = React12.useContext(NumberFieldScrubAreaContext);
  if (context === void 0) {
    throw new Error("Base UI: NumberFieldScrubAreaContext is missing. NumberFieldScrubArea parts must be placed within <NumberField.ScrubArea>.");
  }
  return context;
}

// node_modules/@base-ui-components/react/esm/number-field/utils/getViewportRect.js
function getViewportRect(teleportDistance, scrubAreaEl) {
  const win = getWindow(scrubAreaEl);
  const rect = scrubAreaEl.getBoundingClientRect();
  if (rect && teleportDistance != null) {
    return {
      x: rect.left - teleportDistance / 2,
      y: rect.top - teleportDistance / 2,
      width: rect.right + teleportDistance / 2,
      height: rect.bottom + teleportDistance / 2
    };
  }
  const vV = win.visualViewport;
  if (vV) {
    return {
      x: vV.offsetLeft,
      y: vV.offsetTop,
      width: vV.offsetLeft + vV.width,
      height: vV.offsetTop + vV.height
    };
  }
  return {
    x: 0,
    y: 0,
    width: win.document.documentElement.clientWidth,
    height: win.document.documentElement.clientHeight
  };
}

// node_modules/@base-ui-components/react/esm/number-field/utils/subscribeToVisualViewportResize.js
function subscribeToVisualViewportResize(element, visualScaleRef) {
  const vV = getWindow(element).visualViewport;
  if (!vV) {
    return () => {
    };
  }
  function handleVisualResize() {
    if (vV) {
      visualScaleRef.current = vV.scale;
    }
  }
  handleVisualResize();
  vV.addEventListener("resize", handleVisualResize);
  return () => {
    vV.removeEventListener("resize", handleVisualResize);
  };
}

// node_modules/@base-ui-components/react/esm/number-field/scrub-area/NumberFieldScrubArea.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var NumberFieldScrubArea = React13.forwardRef(function NumberFieldScrubArea2(componentProps, forwardedRef) {
  const {
    render,
    className,
    direction = "horizontal",
    pixelSensitivity = 2,
    teleportDistance,
    ...elementProps
  } = componentProps;
  const {
    state
  } = useNumberFieldRootContext();
  const {
    isScrubbing,
    setIsScrubbing,
    disabled,
    readOnly,
    value,
    inputRef,
    incrementValue,
    getStepAmount
  } = useNumberFieldRootContext();
  const latestValueRef = useLatestRef(value);
  const scrubAreaRef = React13.useRef(null);
  const isScrubbingRef = React13.useRef(false);
  const scrubAreaCursorRef = React13.useRef(null);
  const virtualCursorCoords = React13.useRef({
    x: 0,
    y: 0
  });
  const visualScaleRef = React13.useRef(1);
  const [isTouchInput, setIsTouchInput] = React13.useState(false);
  const [isPointerLockDenied, setIsPointerLockDenied] = React13.useState(false);
  React13.useEffect(() => {
    if (!isScrubbing || !scrubAreaCursorRef.current) {
      return void 0;
    }
    return subscribeToVisualViewportResize(scrubAreaCursorRef.current, visualScaleRef);
  }, [isScrubbing]);
  const updateCursorTransform = useEventCallback((x, y) => {
    if (scrubAreaCursorRef.current) {
      scrubAreaCursorRef.current.style.transform = `translate3d(${x}px,${y}px,0) scale(${1 / visualScaleRef.current})`;
    }
  });
  const onScrub = React13.useCallback(({
    movementX,
    movementY
  }) => {
    const virtualCursor = scrubAreaCursorRef.current;
    const scrubAreaEl = scrubAreaRef.current;
    if (!virtualCursor || !scrubAreaEl) {
      return;
    }
    const rect = getViewportRect(teleportDistance, scrubAreaEl);
    const coords = virtualCursorCoords.current;
    const newCoords = {
      x: Math.round(coords.x + movementX),
      y: Math.round(coords.y + movementY)
    };
    const cursorWidth = virtualCursor.offsetWidth;
    const cursorHeight = virtualCursor.offsetHeight;
    if (newCoords.x + cursorWidth / 2 < rect.x) {
      newCoords.x = rect.width - cursorWidth / 2;
    } else if (newCoords.x + cursorWidth / 2 > rect.width) {
      newCoords.x = rect.x - cursorWidth / 2;
    }
    if (newCoords.y + cursorHeight / 2 < rect.y) {
      newCoords.y = rect.height - cursorHeight / 2;
    } else if (newCoords.y + cursorHeight / 2 > rect.height) {
      newCoords.y = rect.y - cursorHeight / 2;
    }
    virtualCursorCoords.current = newCoords;
    updateCursorTransform(newCoords.x, newCoords.y);
  }, [teleportDistance, updateCursorTransform]);
  const onScrubbingChange = React13.useCallback((scrubbingValue, {
    clientX,
    clientY
  }) => {
    ReactDOM.flushSync(() => {
      setIsScrubbing(scrubbingValue);
    });
    const virtualCursor = scrubAreaCursorRef.current;
    if (!virtualCursor || !scrubbingValue) {
      return;
    }
    const initialCoords = {
      x: clientX - virtualCursor.offsetWidth / 2,
      y: clientY - virtualCursor.offsetHeight / 2
    };
    virtualCursorCoords.current = initialCoords;
    updateCursorTransform(initialCoords.x, initialCoords.y);
  }, [setIsScrubbing, updateCursorTransform]);
  React13.useEffect(function registerGlobalScrubbingEventListeners() {
    if (!inputRef.current || disabled || readOnly) {
      return void 0;
    }
    let cumulativeDelta = 0;
    function handleScrubPointerUp(event) {
      try {
        ownerDocument(scrubAreaRef.current).exitPointerLock();
      } catch {
      } finally {
        isScrubbingRef.current = false;
        onScrubbingChange(false, event);
      }
    }
    function handleScrubPointerMove(event) {
      if (!isScrubbingRef.current) {
        return;
      }
      event.preventDefault();
      onScrub(event);
      const {
        movementX,
        movementY
      } = event;
      cumulativeDelta += direction === "vertical" ? movementY : movementX;
      if (Math.abs(cumulativeDelta) >= pixelSensitivity) {
        cumulativeDelta = 0;
        const dValue = direction === "vertical" ? -movementY : movementX;
        incrementValue(dValue * (getStepAmount(event) ?? DEFAULT_STEP), 1);
      }
    }
    const win = getWindow(inputRef.current);
    win.addEventListener("pointerup", handleScrubPointerUp, true);
    win.addEventListener("pointermove", handleScrubPointerMove, true);
    return () => {
      win.removeEventListener("pointerup", handleScrubPointerUp, true);
      win.removeEventListener("pointermove", handleScrubPointerMove, true);
    };
  }, [disabled, readOnly, incrementValue, latestValueRef, getStepAmount, inputRef, onScrubbingChange, onScrub, direction, pixelSensitivity]);
  React13.useEffect(function registerScrubberTouchPreventListener() {
    const element2 = scrubAreaRef.current;
    if (!element2 || disabled || readOnly) {
      return void 0;
    }
    function handleTouchStart(event) {
      if (event.touches.length === 1) {
        event.preventDefault();
      }
    }
    element2.addEventListener("touchstart", handleTouchStart);
    return () => {
      element2.removeEventListener("touchstart", handleTouchStart);
    };
  }, [disabled, readOnly]);
  const defaultProps = {
    role: "presentation",
    style: {
      touchAction: "none",
      WebkitUserSelect: "none",
      userSelect: "none"
    },
    async onPointerDown(event) {
      const isMainButton = !event.button || event.button === 0;
      if (event.defaultPrevented || readOnly || !isMainButton || disabled) {
        return;
      }
      const isTouch = event.pointerType === "touch";
      setIsTouchInput(isTouch);
      if (event.pointerType === "mouse") {
        event.preventDefault();
        inputRef.current?.focus();
      }
      isScrubbingRef.current = true;
      onScrubbingChange(true, event.nativeEvent);
      if (!isTouch && !isWebKit) {
        try {
          await ownerDocument(scrubAreaRef.current).body.requestPointerLock();
          setIsPointerLockDenied(false);
        } catch (error2) {
          setIsPointerLockDenied(true);
        } finally {
          ReactDOM.flushSync(() => {
            onScrubbingChange(true, event.nativeEvent);
          });
        }
      }
    }
  };
  const element = useRenderElement("span", componentProps, {
    ref: [forwardedRef, scrubAreaRef],
    state,
    props: [defaultProps, elementProps],
    customStyleHookMapping: styleHookMapping
  });
  const contextValue = React13.useMemo(() => ({
    isScrubbing,
    isTouchInput,
    isPointerLockDenied,
    scrubAreaCursorRef,
    scrubAreaRef,
    direction,
    pixelSensitivity,
    teleportDistance
  }), [isScrubbing, isTouchInput, isPointerLockDenied, direction, pixelSensitivity, teleportDistance]);
  return (0, import_jsx_runtime2.jsx)(NumberFieldScrubAreaContext.Provider, {
    value: contextValue,
    children: element
  });
});
if (true) NumberFieldScrubArea.displayName = "NumberFieldScrubArea";

// node_modules/@base-ui-components/react/esm/number-field/scrub-area-cursor/NumberFieldScrubAreaCursor.js
var React14 = __toESM(require_react(), 1);
var ReactDOM2 = __toESM(require_react_dom(), 1);
var NumberFieldScrubAreaCursor = React14.forwardRef(function NumberFieldScrubAreaCursor2(componentProps, forwardedRef) {
  const {
    render,
    className,
    ...elementProps
  } = componentProps;
  const {
    state
  } = useNumberFieldRootContext();
  const {
    isScrubbing,
    isTouchInput,
    isPointerLockDenied,
    scrubAreaCursorRef
  } = useNumberFieldScrubAreaContext();
  const [domElement, setDomElement] = React14.useState(null);
  const shouldRender = isScrubbing && !isWebKit && !isTouchInput && !isPointerLockDenied;
  const element = useRenderElement("span", componentProps, {
    enabled: shouldRender,
    ref: [forwardedRef, scrubAreaCursorRef, setDomElement],
    state,
    props: [{
      role: "presentation",
      style: {
        position: "fixed",
        top: 0,
        left: 0,
        pointerEvents: "none"
      }
    }, elementProps],
    customStyleHookMapping: styleHookMapping
  });
  return element && ReactDOM2.createPortal(element, ownerDocument(domElement).body);
});
if (true) NumberFieldScrubAreaCursor.displayName = "NumberFieldScrubAreaCursor";
export {
  index_parts_exports as NumberField
};
//# sourceMappingURL=@base-ui-components_react_number-field.js.map
